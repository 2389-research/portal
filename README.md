# WebRTC Video Chat

A simple peer-to-peer video chat application using WebRTC, Python, and modular JavaScript with Parcel bundler.

**NEW**: Check out our Expo version for React Native in the `expo-app` directory!

## Features

- Create and join video chat rooms
- Real-time video and audio communication
- Text chat with message notifications
- Toggle self-view (hide/show your own video)
- Device selection (camera and microphone)
- Mute audio and pause video controls
- Copy room ID to invite others
- Debug logging for troubleshooting
- Screen sharing functionality
- Modular frontend architecture with clean separation of concerns

## Requirements

- Python 3.7+
- Flask
- Node.js and npm (for Parcel bundler)
- Modern web browser with WebRTC support (Chrome, Firefox, Safari, Edge)

## Project Structure

- `src/`: Frontend source code
  - `js/`: JavaScript modules
    - `api/`: Data access layer for backend communication
      - `ApiInterface.js`: Abstract interface defining backend contract
      - `FlaskApiClient.js`: Implementation for Flask backend
      - `MockApiClient.js`: Mock implementation for testing
      - `FirebaseApiClient.js`: Implementation for Firebase
      - `PocketBaseApiClient.js`: Implementation for PocketBase
      - `ApiProvider.js`: Factory for API client instances
      - `config.js`: Backend configuration
      - `BackendSelector.js`: UI widget for switching backends in development
    - `webrtc.js`: WebRTC connection handling
    - `media.js`: Media device access and control
    - `chat.js`: Chat functionality
    - `signaling.js`: Communication with server using the data access layer
    - `room.js`: Main room page logic
    - `index.js`: Home page logic
  - `css/`: Stylesheet files
  - `html/`: HTML templates
- `public/`: Built frontend files (generated by Parcel)
- `server.py`: Flask server
- `expo-app/`: React Native implementation using Expo and UI Kitten

## Installation

### Local Setup

1. Clone this repository
2. Install Python requirements:

```bash
pip install -r requirements.txt
```

3. Install Node.js dependencies:

```bash
npm install
```

4. Build the frontend:

```bash
npm run build
```

### Docker Setup

1. Build and run using Docker Compose:

```bash
docker-compose up --build
```

2. Or, build and run using Docker directly:

```bash
docker build -t webrtc-video-chat .
docker run -p 5000:5000 webrtc-video-chat
```

## Usage

### Running in Development Mode

1. Start the Parcel development server:

```bash
npm start
```

2. In a separate terminal, start the Flask server:

```bash
python server.py
```

3. Open your browser and navigate to `http://localhost:5000`

**Note:** Hot Module Reloading (HMR) is disabled by default because it conflicts with our WebRTC implementation. If you want to enable it, remove the `--no-hmr` flag from the start script in package.json. However, be aware that this might cause WebSocket connection errors if your Flask server doesn't support WebSockets.

### Running in Production

1. Build the frontend:

```bash
npm run build
```

2. Start the Flask server:

```bash
python server.py
```

3. Open your browser and navigate to `http://localhost:5000`

### Deploying to Fly.io

1. Install the Fly CLI tool:

```bash
curl -L https://fly.io/install.sh | sh
```

2. Log in to your Fly.io account:

```bash
fly auth login
```

3. Deploy the application:

```bash
fly launch
```

4. For subsequent deployments:

```bash
fly deploy
```

## Room Usage

1. Create a new room or join an existing room by entering its Room ID

2. Share the Room ID with others to invite them to your video chat

3. Use the controls to toggle audio/video, show/hide self-view, and open the chat

4. Allow camera and microphone access when prompted

## Debug Logging

The application includes comprehensive debug logging:

- Server-side logs are printed to the console
- Client-side logs can be viewed in the browser's developer console

## Notes

- This application uses a simplified signaling mechanism
- In a production environment, you would typically:
  - Use WebSockets for real-time signaling
  - Implement user authentication
  - Add additional TURN servers for NAT traversal
  - Enhance security features

## Troubleshooting

- If you can't see or hear other participants:
  - Check that your camera and microphone are working
  - Make sure you've allowed the browser to access your media devices
  - Try a different browser or device
  - Check if your network allows WebRTC traffic
  - Open browser console to see debug messages

## Technical Implementation

- **Server**: Flask web server for serving pages and handling signaling
- **Client**: Modular JavaScript implementation with WebRTC
- **Data Access Layer**: Abstraction for backend communication, allowing multiple backend implementations
- **Signaling**: REST API endpoints (in a real app, this would use WebSockets)
- **STUN servers**: Google's public STUN servers for NAT traversal
- **Media Negotiation**: Standard WebRTC offer/answer mechanism

## Alternative Backends and Data Access Layer

The application features a comprehensive Data Access Layer (DAL) that abstracts all backend communication, allowing for easy switching between different backend implementations.

### Features of the Data Access Layer

- **Multiple Backend Support**: Switch between backends without changing application code
- **Input Validation**: Comprehensive validation of all parameters before API calls 
- **Error Handling**: Robust error handling with retries, timeouts, and graceful degradation
- **Configurability**: Environment-specific configurations with runtime updates
- **Health Monitoring**: Connection status tracking with event notifications
- **Developer Tools**: UI widget for configuring backends during development

### Available Backend Implementations

1. **Flask API Client**: The default implementation using the Python Flask backend
2. **Firebase API Client**: Implementation using Firebase Realtime Database
3. **PocketBase API Client**: Implementation using PocketBase
4. **Mock API Client**: An in-memory implementation for development and testing without a server

### Using the Mock Backend

For development and testing without running a server:

1. **URL Parameter**: Add `?api=mock` to the URL to use the mock backend
2. **UI Widget**: Use the backend selector widget in development mode (press Ctrl+Shift+B)
3. **Configuration**: Set `window.ENV.API_CONFIG = { type: 'mock' }` in the console
4. **Environment**: Use the TEST environment which defaults to the mock backend

### Adding a New Backend Implementation

To add a new backend implementation (e.g., Node.js, Go, Java):

1. **Create Implementation**: Extend the `ApiInterface` abstract class
2. **Register Backend**: Add it to the configuration system
3. **Configure Options**: Add any backend-specific configuration options
4. **Test**: Validate your implementation using the provided tools

Detailed implementation instructions are available in `src/js/api/README.md`.

### Developer Tools

The DAL includes several developer tools:

1. **Backend Selector**: A UI widget to switch backends and configure options at runtime
2. **Configuration API**: Programmatic control of backend settings
3. **Connection Indicator**: Visual indication of backend connection status
4. **Console Access**: Global objects for debugging via browser console

In development mode, press `Ctrl+Shift+B` or `Cmd+Shift+B` to access the backend selector.

## Expo Implementation

We've also created a React Native version of this application using Expo and UI Kitten. This implementation includes:

- Cross-platform support (web, iOS, Android)
- Modern React Native UI with UI Kitten components
- Same core WebRTC functionality
- Support for the same backend options (Firebase, PocketBase, Flask, Mock)

To try the Expo version:

1. Navigate to the `expo-app` directory
2. Install dependencies: `npm install`
3. Start the app: `npm run web` (for web), `npm run ios` (for iOS), or `npm run android` (for Android)

See the [Expo app README](./expo-app/README.md) for more details.